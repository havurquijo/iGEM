<nav id="page-navbar" class="page-toc sticky-top navbar flex-column align-items-stretch p-3"
     style="top: 70px; visibility: hidden;">
  <h5 class="ms-2">Content</h5>
  <nav class="nav nav-pills flex-column" id="page-nav-links"></nav>
</nav>

<script>
document.addEventListener("DOMContentLoaded", function () {
  const mainNav = document.querySelector('.fixed-top');
  const mainNavHeight = mainNav ? mainNav.offsetHeight : 56;
  const scrollOffset = mainNavHeight + 20;
  document.documentElement.style.scrollPaddingTop = scrollOffset + 'px';

  setTimeout(function () {
    const contentEl = document.getElementById('main-content');
    const navLinksContainer = document.getElementById('page-nav-links');
    const pageNavbar = document.getElementById('page-navbar');
    if (!contentEl || !navLinksContainer || !pageNavbar) return;

    // ===== Coleta headings e filtra os que não queremos no TOC =====
    // Dica: para esconder qualquer heading, use data-toc="false"
    const all = Array.from(contentEl.querySelectorAll('h1, h2, h3'))
      .filter(h => !h.closest('.accordion-header')) // evita poluir com títulos do accordion
      .filter(h => h.getAttribute('data-toc') !== 'false');

    // Define nível-base: se houver H1 usamos H1; senão, H2 vira topo.
    const hasH1 = all.some(h => h.tagName === 'H1');
    const base = hasH1 ? 1 : 2;

    // Mantém só até H(base+2) (máx H3)
    const headings = all.filter(h => {
      const lvl = Number(h.tagName.substring(1));
      return lvl >= base && lvl <= base + 2;
    });

    if (headings.length <= 1) { pageNavbar.style.visibility = 'hidden'; return; }
    pageNavbar.style.visibility = 'visible';

    // ===== Constrói TOC hierárquico =====
    navLinksContainer.innerHTML = '';
    let lastTop = null;      // H1 ou H2 (quando base=2)
    let lastTopSub = null;   // container de H2 sob H1 (ou null se base=2)
    let lastH2 = null;       // último H2 corrente
    let lastH2Sub = null;    // container de H3 sob este H2

    function ensureId(el, prefix){
      if (!el.id) el.id = prefix + '-' + Math.random().toString(36).slice(2,8);
      return el.id;
    }
    function addLink(container, el, level){
      const id = ensureId(el, 'toc-' + el.tagName.toLowerCase());
      const a = document.createElement('a');
      a.className = 'nav-link toc-link level-' + level + (level === 1 ? ' fw-semibold' : '');
      a.href = '#' + id;
      a.textContent = el.textContent.trim();
      container.appendChild(a);
      return a;
    }
    function makeSubContainer(level){
      const d = document.createElement('div');
      d.className = 'nav flex-column toc-sub level-' + level;
      return d;
    }

    headings.forEach(h => {
      const lvl = Number(h.tagName.substring(1));
      if (lvl === base) {
        // Topo (H1 se base=1; H2 se base=2)
        lastTop = addLink(navLinksContainer, h, 1);
        lastTopSub = makeSubContainer(2); // onde vão H2 (ou H3 se base=2)? -> H2
        navLinksContainer.appendChild(lastTopSub);
        lastH2 = null;
        lastH2Sub = null;
      } else if (lvl === base + 1) {
        // Segundo nível (H2 quando base=1; H3 quando base=2)
        if (!lastTopSub) { lastTopSub = makeSubContainer(2); navLinksContainer.appendChild(lastTopSub); }
        lastH2 = addLink(lastTopSub, h, 2);
        lastH2Sub = makeSubContainer(3);
        lastTopSub.appendChild(lastH2Sub);
      } else if (lvl === base + 2) {
        // Terceiro nível (H3)
        if (!lastH2Sub) {
          // se não houver H2 anterior, cria um "órfão" embaixo do topo atual
          lastH2Sub = makeSubContainer(3);
          if (lastTopSub) lastTopSub.appendChild(lastH2Sub);
          else navLinksContainer.appendChild(lastH2Sub);
        }
        addLink(lastH2Sub, h, 3);
      }
    });

    // Bootstrap ScrollSpy
    var spy = bootstrap.ScrollSpy.getInstance(document.body);
    if (spy) spy.refresh();
    else new bootstrap.ScrollSpy(document.body, { target: '#page-navbar', offset: scrollOffset });
  }, 100);
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function () {
  const desktop = window.matchMedia('(hover: hover) and (pointer: fine)');
  if (!desktop.matches) return; // mobile/tablet continuam no click padrão

  // rastreia forma de interação p/ distinguir foco por teclado x mouse
  let lastInput = 'mouse';
  window.addEventListener('keydown', (e) => {
    if (['Tab','ArrowDown','ArrowUp','ArrowLeft','ArrowRight'].includes(e.key)) {
      lastInput = 'keyboard';
    }
  }, true);
  window.addEventListener('pointerdown', () => { lastInput = 'mouse'; }, true);

  document.querySelectorAll('.navbar .dropdown').forEach((dd) => {
    const toggle = dd.querySelector('.dropdown-toggle');
    const menu   = dd.querySelector('.dropdown-menu');
    if (!toggle || !menu) return;

    // 1) Remove o acionamento por click do Bootstrap no desktop
    toggle.removeAttribute('data-bs-toggle');

    // 2) Cria (ou recria) a instância programaticamente
    const existing = bootstrap.Dropdown.getInstance(toggle);
    if (existing) existing.dispose();
    const inst = new bootstrap.Dropdown(toggle, { autoClose: 'outside' });

    // 3) Bloqueia click e teclas de ativação (só hover abre)
    toggle.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopImmediatePropagation();
      e.stopPropagation();
    }, true);
    toggle.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
    // evita foco por mouse (que dispararia 'focus'); preserva Tab
    toggle.addEventListener('pointerdown', (e) => {
      // não impedir Tab; aqui é pointer (mouse/trackpad)
      // apenas evita que o foco mude por mouse
      e.preventDefault();
    }, true);

    let hideTimer;
    const open  = () => { clearTimeout(hideTimer); inst.show();  toggle.setAttribute('aria-expanded','true'); };
    const close = () => { hideTimer = setTimeout(() => { inst.hide(); toggle.setAttribute('aria-expanded','false'); }, 150); };

    // 4) Hover abre/fecha
    dd.addEventListener('mouseenter', open);
    dd.addEventListener('mouseleave', close);
    menu.addEventListener('mouseenter', () => clearTimeout(hideTimer));
    menu.addEventListener('mouseleave', close);

    // 5) Acessibilidade: foco só abre se veio do teclado (Tab)
    toggle.addEventListener('focus', () => { if (lastInput === 'keyboard') open(); });
  });
});
</script>
